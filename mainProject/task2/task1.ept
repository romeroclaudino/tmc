node client(endS: bool) returns (currentState: int)
let
    automaton
     state Idle do
     currentState = 0;
     unless endS then Ordering

     state Ordering do
     currentState = 1;
     unless endS then Waiting

     state Waiting do
     currentState = 2;
     unless endS then Eating

     state Eating do
     currentState = 3;
     unless endS then Idle
    end
tel


node robot(guestH, foodO, deliveringF, c: bool) returns (currentState: int)
let
    automaton
     state Idle do
     currentState = 0;
     unless guestH & (not foodO & not deliveringF) then GuestHosting |
          	foodO & (not guestH & not deliveringF) then FoodOrdering |
            deliveringF & (not guestH & not foodO) then DeliveringFood

     state GuestHosting do
     currentState = 1;
     unless c then Idle

     state FoodOrdering do
     currentState = 2;
     unless c then DeliveringFood

     state DeliveringFood do
     currentState = 3;
     unless c then Idle
    end
tel

(* 1 - GuestHosting
2 - FoodOrdering
3 - DeliveringFood *)

node mainNode(clientEndS, clientEndS2: bool) returns (currentStRobot1, currentStRobot2, currentStRobot3, currentStRobot4, currentStClient, currentStClient2: int)    
contract
        var rule1, rule2, rule3, rule4: bool; 
        let
        (*One group of clients*)
            rule1 = (currentStRobot1 = 1 or currentStRobot2 = 1 or currentStRobot3 = 1) &
                    (currentStRobot1 = 2 or currentStRobot2 = 2 or currentStRobot3 = 2) &
                    (currentStRobot1 = 3 or currentStRobot2 = 3 or currentStRobot3 = 3);

            rule2 = (currentStRobot1 + currentStRobot2 + currentStRobot3 = 6) & 
                    (currentStRobot1 = 0 or currentStRobot2 = 0 or currentStRobot3 = 0);
        (*One group of clients*)
        (*Two groups of clients*)
        	rule3 = (currentStRobot1 = 1 or currentStRobot2 = 1 or currentStRobot3 = 1) &
                    (currentStRobot1 = 2 or currentStRobot2 = 2 or currentStRobot3 = 2) &
                    (currentStRobot1 = 3 or currentStRobot2 = 3 or currentStRobot3 = 3) &
                    (currentStRobot4 = 2);

            rule4 = (currentStRobot1 + currentStRobot2 + currentStRobot3 + currentStRobot4 = 9) & 
                    (currentStRobot1 = 0 or currentStRobot2 = 0 or currentStRobot3 = 0 or currentStRobot4 = 0);
        (*Two groups of clients*)

        tel
     enforce (not (currentStClient = 1 & currentStClient2 = 0) or rule1) &
             (not (currentStClient = 2 & currentStClient2 = 0) or rule2) &

             (not (currentStClient = 1 & currentStClient2 = 1) or rule3) &
             (not (currentStClient = 2 & currentStClient2 = 2) or rule4)    

     with(robot1GuestH, robot1FoodO, robot1DeliveringF, c1,
          robot2GuestH, robot2FoodO, robot2DeliveringF, c2,
          robot3GuestH, robot3FoodO, robot3DeliveringF, c3,
          robot4GuestH, robot4FoodO, robot4DeliveringF, c4: bool)
let
    currentStRobot1 = inlined robot(robot1GuestH, robot1FoodO, robot1DeliveringF, c1);
    currentStRobot2 = inlined robot(robot2GuestH, robot2FoodO, robot2DeliveringF, c2);
    currentStRobot3 = inlined robot(robot3GuestH, robot3FoodO, robot3DeliveringF, c3);
    currentStRobot4 = inlined robot(robot4GuestH, robot4FoodO, robot4DeliveringF, c4);
    currentStClient = inlined client(clientEndS);
    currentStClient2 = inlined client(clientEndS2)
tel