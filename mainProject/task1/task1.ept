node client(endS: bool) returns (currentState: int)
let
    automaton
     state Idle do
     currentState = 0;
     unless endS then Arrival

     state Arrival do
     currentState = 1;
     unless endS then DoneOrdering

     state DoneOrdering do
     currentState = 2;
     unless endS then DoneEating

     state DoneEating do
     currentState = 3;
     unless endS then Idle
    end
tel


node robot(guestH, foodO, deliveringF, c, c2, endS: bool) returns (currentState: int)
let
    automaton
     state Idle do
     currentState = 0;
     unless guestH & (not foodO & not deliveringF) then GuestHosting |
          	foodO & (not guestH & not deliveringF) then FoodOrdering |
            deliveringF & (not guestH & not foodO) then DeliveringFood

     state GuestHosting do
     currentState = 1;
     unless endS & c or c2 then Idle

     state FoodOrdering do
     currentState = 2;
     unless endS & c or c2 then DeliveringFood

     state DeliveringFood do
     currentState = 3;
     unless endS & c or c2 then Idle
    end
tel

(* 1 - GuestHosting
2 - FoodOrdering
3 - DeliveringFood *)

node mainNode(robot1endS,robot2endS, robot3endS, clientEndS: bool) returns (currentStRobot1, currentStRobot2, currentStRobot3, currentStClient: int)    
contract
        (* var rule1: bool;  *)
        var rule1, rule2: bool; 
        let
        	rule1 = (currentStRobot1 = 1 or currentStRobot2 = 1 or currentStRobot3 = 1) &
                    (currentStRobot1 = 2 or currentStRobot2 = 2 or currentStRobot3 = 2) &
                    (currentStRobot1 = 3 or currentStRobot2 = 3 or currentStRobot3 = 3);

            (* rule2 = currentStRobot1 + currentStRobot2 + currentStRobot3 > 5 &  *)
                    (* currentStRobot1 = 0 or currentStRobot2 = 0 or currentStRobot3 = 0; *)
               rule2 = currentStRobot1 = 0 or currentStRobot2 = 0 or currentStRobot3 = 0;

            (* rule2 = (currentStRobot1 = 3 & currentStRobot2 = 3) *)
                 (* or (currentStRobot1 = 3 & currentStRobot3 = 3)  *)
                 (* or (currentStRobot2 = 3 & currentStRobot3 = 3); *)
                    
                (* rule1 = (currentStRobot1 + currentStRobot2 + currentStRobot3) = 6; (* & *)
                           currentStRobot1 > 0 & currentStRobot2 > 0 & currentStRobot3 > 0; *)
            (* arrivalScenario = currentStRobot1 = 1 & currentStRobot2 = 2 & currentStRobot3 = 3; *)

        tel
     enforce (not (currentStClient = 1) or rule1) & (not (currentStClient = 2) or rule2)
     with(robot1GuestH, robot1FoodO, robot1DeliveringF, c1, c21,
          robot2GuestH, robot2FoodO, robot2DeliveringF, c2, c22,
          robot3GuestH, robot3FoodO, robot3DeliveringF, c3, c23: bool)
let
    currentStRobot1 = inlined robot(robot1GuestH, robot1FoodO, robot1DeliveringF, c1, c21, robot1endS);
    currentStRobot2 = inlined robot(robot2GuestH, robot2FoodO, robot2DeliveringF, c2, c22, robot2endS);
    currentStRobot3 = inlined robot(robot3GuestH, robot3FoodO, robot3DeliveringF, c3, c23, robot3endS);
    currentStClient = inlined client(clientEndS)
tel